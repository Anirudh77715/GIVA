For building a URL shortener with the features you mentioned, here is the suggested tech stack and roadmap:

### **Tech Stack**
1. **Backend**: **Node.js with Express**
   - **Why**: Node.js is lightweight and well-suited for handling high-concurrency requests, which is crucial for scalability. Express makes routing and middleware management easy.
   - Alternatively, **Golang** is a great choice for performance, but Node.js is often easier to set up and quicker to develop with.
   
2. **Database**: **PostgreSQL**
   - **Why**: Relational databases like PostgreSQL are great for storing mappings between long and short URLs with strong ACID properties. PostgreSQL supports structured data and is reliable for handling the primary use case of mapping long URLs to short ones.
   - If you need to track high-frequency access (like number of hits on short URLs), Redis can be used for caching statistics to reduce database load.

3. **Deployment**: **Vercel**
   - **Why**: Vercel is ideal for deploying serverless applications with ease, and it's well-suited for Node.js. You can deploy the API endpoints quickly and scale them automatically.

---

### **Roadmap & Features**

1. **Step 1: Set Up Project**
   - Initialize a **Node.js** project with Express.
   - Set up a **PostgreSQL** database to store long and short URLs.
   - Use a package like `shortid` or `nanoid` to generate short codes for URLs.

2. **Step 2: Implement API Endpoints**
   - **POST /shorten**: 
     - Accept a long URL as input.
     - Generate a short code and store the mapping in the database.
     - Return the short URL.
   
   - **GET /<short-code>**:
     - Retrieve the long URL from the database using the short code.
     - Redirect the user to the long URL.

3. **Step 3: Add Custom Alias Feature (Bonus)**
   - **POST /shorten?alias=mycustomname**: 
     - Allow users to provide a custom alias for the short URL.
     - Check for duplicate aliases and handle errors.
     - If the alias is valid, store the custom alias with its corresponding long URL.
   
4. **Step 4: Track URL Usage Statistics**
   - Add a counter in the database for each short URL to track how many times it’s been accessed.
   - Optionally, store additional data such as IP addresses or timestamps if needed.

5. **Step 5: Handle Edge Cases**
   - Duplicate URLs should always generate the same short code.
   - Ensure invalid URLs are handled gracefully with appropriate error messages.
   - Check for duplicate custom aliases and handle expired links.
   - For expired links, you could implement a TTL (Time To Live) and clean up the database.

6. **Step 6: Scalability**
   - Use **Redis** for caching frequent short URLs to minimize database load.
   - Ensure that your system can handle high traffic by scaling your Vercel deployment, which handles auto-scaling for serverless applications.

7. **Step 7: Testing & Optimization**
   - Add unit tests and E2E tests for all critical functionality.
   - Optimize database queries for speed, especially when dealing with large datasets.

8. **Step 8: Deployment**
   - Deploy the app on **Vercel**.
   - Ensure environment variables for database credentials are securely configured.

---

### **Bonus Features (Custom Alias & Expired Links)**
1. **Custom Alias**:
   - Allow users to submit their preferred alias (e.g., `/shorten?alias=customname`).
   - Ensure no duplicates (check if the alias already exists in the database).
   - If the alias is already in use, return an error message.
   
2. **Expired Links**:
   - Add a **timestamp** when storing the long URL and set an expiration date.
   - Use a background job or cron job to periodically clean up expired links.
   
3. **Scaling Considerations**:
   - Use Redis for storing frequently accessed short URLs to improve lookup times.
   - Use **Vercel’s Serverless Functions** for auto-scaling with minimal configuration.

With this stack, your URL shortener will be robust, scalable, and feature-rich.